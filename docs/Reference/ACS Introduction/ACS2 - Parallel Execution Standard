ACS2 - Parallel Execution Standard

ACS2 enables parallel execution of transactions by providing necessary resource information.

### Interface

A contract inheriting ACS2 must implement:

#### Methods

| Method Name      | Request Type        | Response Type       | Description                                           |
|------------------|---------------------|---------------------|-------------------------------------------------------|
| GetResourceInfo  | aelf.Transaction    | acs2.ResourceInfo   | Retrieves resource dependencies for transaction exec. |

### Types

#### acs2.ResourceInfo

| Field             | Type                 | Description                        | Label     |
|-------------------|----------------------|------------------------------------|-----------|
| write_paths       | aelf.ScopedStatePath | State paths written during execution| repeated  |
| read_paths        | aelf.ScopedStatePath | State paths read during execution   | repeated  |
| non_parallelizable| bool                  | Indicates if transaction is non-parallelizable.|           |

#### Other Types (Omitted for brevity)

Several other types like `aelf.Address`, `aelf.BinaryMerkleTree`, `aelf.LogEvent`, etc., are used within `acs2.ResourceInfo`.

### Usage

aelf uses State Paths to manage data storage, ensuring transaction grouping based on accessed paths for efficient parallel execution.

### Implementation

Token contract, for example, modifies balances through method Transfer. GetResourceInfo must notify ITransactionGrouper of accessed state paths.

```cs
var args = TransferInput.Parser.ParseFrom(txn.Params);
var resourceInfo = new ResourceInfo
{
    Paths =
    {
        GetPath(nameof(TokenContractState.Balances), txn.From.ToString(), args.Symbol),
        GetPath(nameof(TokenContractState.Balances), args.To.ToString(), args.Symbol),
    }
};
return resourceInfo;
```

### Test
Test transaction parallelizability using ITransactionGrouper's GroupAsync method with sample transactions.

    ```cs
    var keyPair1 = SampleECKeyPairs.KeyPairs[0];
    var acs2DemoContractStub1 = GetACS2DemoContractStub(keyPair1);
    var keyPair2 = SampleECKeyPairs.KeyPairs[1];
    var acs2DemoContractStub2 = GetACS2DemoContractStub(keyPair2);

    var transactionGrouper = Application.ServiceProvider.GetRequiredService<ITransactionGrouper>();
    var blockchainService = Application.ServiceProvider.GetRequiredService<IBlockchainService>();
    var chain = await blockchainService.GetChainAsync();

    // Test parallel execution scenario
    {
        var groupedTransactions = await transactionGrouper.GroupAsync(new ChainContext
        {
            BlockHash = chain.BestChainHash,
            BlockHeight = chain.BestChainHeight
        }, new List<Transaction>
        {
            acs2DemoContractStub1.TransferCredits.GetTransaction(new TransferCreditsInput
            {
                To = Address.FromPublicKey(SampleECKeyPairs.KeyPairs[2].PublicKey),
                Symbol = "ELF",
                Amount = 1
            }),
            acs2DemoContractStub2.TransferCredits.GetTransaction(new TransferCreditsInput
            {
                To = Address.FromPublicKey(SampleECKeyPairs.KeyPairs[3].PublicKey),
                Symbol = "ELF",
                Amount = 1
            }),
        });
        groupedTransactions.Parallelizables.Count.ShouldBe(2);
    }

    // Test non-parallel execution scenario
    {
        var groupedTransactions = await transactionGrouper.GroupAsync(new ChainContext
        {
            BlockHash = chain.BestChainHash,
            BlockHeight = chain.BestChainHeight
        }, new List<Transaction>
        {
            acs2DemoContractStub1.TransferCredits.GetTransaction(new TransferCreditsInput
            {
                To = Address.FromPublicKey(SampleECKeyPairs.KeyPairs[2].PublicKey),
                Symbol = "ELF",
                Amount = 1
            }),
            acs2DemoContractStub2.TransferCredits.GetTransaction(new TransferCreditsInput
            {
                To = Address.FromPublicKey(SampleECKeyPairs.KeyPairs[2].PublicKey),
                Symbol = "ELF",
                Amount = 1
            }),
        });
        groupedTransactions.Parallelizables.Count.ShouldBe(1);
    }
    ```

### Example

For an example of implementing GetResourceInfo, refer to the MultiToken contract, ensuring transaction fees are considered for the keys involved.
